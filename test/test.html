<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>diff test</title>
</head>
<body>
<script>
const ADD = 'add'
const REMOVE = 'remove'
const REPLACE = 'replace'

function Patch (type, path, value, leftValue) {
  this.type = type
  this.path = path
  this.value = value
  this.leftValue = leftValue
}

// compare left and right values
function diffValues (left, right, path, patchs) {
  // filter functin and null
  if (typeof left === 'function' || left === null) {
    patchs.push(new Patch(REPLACE, path, right, left))
  } else if (Array.isArray(left)) {
    // diff array
    if (Array.isArray(right)) {
      walkArray(left, right, path, patchs)
    } else {
      patchs.push(new Patch(REPLACE, path, right, left))
    }
  } else if (typeof left === 'object') {
    // diff object
    if (
        right !== null &&
        typeof right === 'object' &&
        !Array.isArray(right)
    ) {
      // filter Date object
      if (left instanceof Date || right instanceof Date) {
        patchs.push(new Patch(REPLACE, path, right, left))
      } else {
        walkObject(left, right, path, patchs)
      }
    } else {
      patchs.push(new Patch(REPLACE, path, right, left))
    }
  } else {
    patchs.push(new Patch(REPLACE, path, right, left))
  }
}

function walkArray (a, b, base, patchs) {
  if (a.length <= b.length) {
    let len = a.length
    while (--len >= 0) {
      if (a[len] !== b[len]) {
        const path = `${base}[${len}]`
        diffValues(a[len], b[len], path, patchs)
      }
    }
  
    if (b.length > a.length) {
      len = b.length
      while (--len >= a.length) {
        const path = `${base}[${len}]`
        patchs.push(new Patch(ADD, path, b[len], a[len]))
      }
    }
  } else {
    // if new list less than old list,
    // no need diff, direct replac is fine.
    patchs.push(new Patch(REPLACE, base, b, a))
  }
}

function walkObject (a, b, base, patchs) {
  // walk left object
  for (const key in a) {
    // current path
    const path = `${base}['${key}']`

    if (!(key in b)) {
      patchs.push(new Patch(REMOVE, path, null, a[key]))
    } else if (a[key] !== b[key]) {
      diffValues(a[key], b[key], path, patchs)

      // don't use `delete` statement,
      // will destroy the stability of the `object` structure
      // delete b[key]
    }
  }

  // walk right object
  for (const key in b) {
    if (!(key in a)) {
      const path = `${base}['${key}']`
      patchs.push(new Patch(ADD, path, b[key], null))
    }
  }
}

// root `a` and root `b` is an object
function diff (a, b, basePath) {
  const patchs = []
  walkObject(a, b, basePath, patchs)
  return patchs
}

const REG = /[^\[]+(?=\])/g
const filter = key => key.replace(/'/g, '')

const separatePath = (obj, path) => {
  const keys = path.match(REG)

  if (keys) {
    let i = -1
    let key = null
    let target = obj
    let prevTarget = null
    while (i++ < keys.length - 2) {
      prevTarget = target
      key = filter(keys[i])
      target = target[key]
    }

    return [target, key, prevTarget, filter(keys[keys.length -1])]
  }
}

const restore = (obj, patchs) => {
  let len = patchs.length
  const delEmpty = new Map()

  while (--len >= 0) {
    const { type, path, leftValue } = patchs[len]
    const parseItem = separatePath(obj, path)

    if (parseItem) {
      const [target, key, prevTarget, lastKey] = parseItem

      // reverse recovery
      switch (type) {
        case REMOVE :
          target[lastKey] = leftValue
          break
        case REPLACE :
          target[lastKey] = leftValue
          break
        case ADD :
          if (Array.isArray(target)) {
            if (target === prevTarget[key]) {
              delEmpty.set(target, { key, prevTarget })
            }
          }
          delete target[lastKey]
          break
      }
    }
  }

  delEmpty.forEach(({ key, prevTarget }, target) => {
    const clone = new target.constructor()
    // remove empty item
    target.forEach(item => clone.push(item))
    prevTarget[key] = clone
  })

  return obj
}

const data = [
{
    name: 'simple values',
    left: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    right: [1, 3, 4, 5, 8, 9, 9.1, 10],
    delta: {
      _t: 'a',
      _1: [2, 0, 0],
      _5: [6, 0, 0],
      _6: [7, 0, 0],
      6: [9.1],
    },
    reverse: {
      _t: 'a',
      1: [2],
      5: [6],
      6: [7],
      _6: [9.1, 0, 0],
      _8: [1, 2],
    },
  },

  {
    name: 'added block',
    left: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    right: [1, 2, 3, 4, 5, 5.1, 5.2, 5.3, 6, 7, 8, 9, 10],
    delta: {
      _t: 'a',
      5: [5.1],
      6: [5.2],
      7: [5.3],
    },
    reverse: {
      _t: 'a',
      _5: [5.1, 0, 0],
      _6: [5.2, 0, 0],
      _7: [5.3, 0, 0],
      _8: [1],
    },
  },
]
const patchs = diff(data[0], data[1])
console.log(patchs)
restore(data[1], patchs)
console.log(data[0], data[1])
</script>
</body>
</html>