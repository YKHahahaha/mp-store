"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const warn=t=>{throw new Error(`\n\n[MpStore warn]: ${t}\n\n`)},assert=(t,e)=>{t||warn(e)},mergeState=(t,e)=>Object.freeze(Object.assign({},t,e)),isEmptyObject=t=>{for(const e in t)return!1;return!0},remove=(t,e)=>{const n=t.indexOf(e);n>-1&&t.splice(n,1)},callHook=(t,e,n)=>{if(t&&"function"==typeof t[e])return t[e].apply(t,n)},createWraper=(t,e,n)=>(function(...s){let a;return"function"==typeof e&&e.apply(this,s),"function"==typeof t&&(a=t.apply(this,s)),"function"==typeof n&&n.apply(this,s),a}),mapObject=(t,e)=>{const n={};for(const s in t)t.hasOwnProperty(s)&&(n[s]=e(t[s]));return n},isPlainObject=t=>{if("object"!=typeof t||null===t)return!1;const e=Object.getPrototypeOf(t);if(null===e)return!0;let n=e;for(;null!==Object.getPrototypeOf(n);)n=Object.getPrototypeOf(n);return e===n};function mixin(t){const e=Object.create(null);if("function"==typeof t){t((t,n)=>{assert("string"==typeof t&&"functin"==typeof n,"Mixed callback parameters are illegal."),assert(!(t in e),`The "${t}" is exist,`),e.name=n})}return e}const ADD=1,REMOVE=2,REPLACE=3;function Patch(t,e,n,s){this.type=t,this.path=e,this.value=n,this.leftValue=s}function diffValues(t,e,n,s){"function"==typeof t||null===t?s.push(new Patch(REPLACE,n,e,t)):Array.isArray(t)?Array.isArray(e)?walkArray(t,e,n,s):s.push(new Patch(REPLACE,n,e,t)):"object"==typeof t?null===e||"object"!=typeof e||Array.isArray(e)?s.push(new Patch(REPLACE,n,e,t)):t instanceof Date||e instanceof Date?s.push(new Patch(REPLACE,n,e,t)):walkObject(t,e,n,s):s.push(new Patch(REPLACE,n,e,t))}function walkArray(t,e,n,s){if(t.length<=e.length){let a=t.length;for(;--a>=0;)if(t[a]!==e[a]){const o=`${n}[${a}]`;diffValues(t[a],e[a],o,s)}if(e.length>t.length)for(a=e.length;--a>=t.length;){const o=`${n}[${a}]`;s.push(new Patch(ADD,o,e[a],t[a]))}}else s.push(new Patch(REPLACE,n,e,t))}function walkObject(t,e,n,s){for(const a in t){const o=`${n}.${a}`;a in e?t[a]!==e[a]&&diffValues(t[a],e[a],o,s):s.push(new Patch(REMOVE,o,null,t[a]))}for(const a in e)if(!(a in t)){const t=`${n}.${a}`;s.push(new Patch(ADD,t,e[a],null))}}const diff=(t,e,n)=>{const s=[];return walkObject(t,e,n,s),s},REG=/(?<=[\[\].])[^\[\].]+/g,separatePath=(t,e)=>{const n=e.match(REG);if(n){let e=-1,s=null,a=t,o=null;for(;e++<n.length-2;)o=a,a=a[s=n[e]];return[a,s,o,n[n.length-1]]}},restore=(t,e)=>{let n=e.length;const s=new Map;for(;--n>=0;){const{type:a,path:o,leftValue:i}=e[n],r=separatePath(t,o);if(r){const[t,e,n,o]=r;switch(a){case REMOVE:case REPLACE:t[o]=i;break;case ADD:Array.isArray(t)&&t===n[e]&&s.set(t,{key:e,prevTarget:n}),delete t[o]}}}return s.forEach(({key:t,prevTarget:e},n)=>{const s=new n.constructor;n.forEach(t=>s.push(t)),e[t]=s}),t},COMMONACTION="*",match=(t,e)=>t.action===COMMONACTION||e===t.action,handleLayer=(t,e,n,s,a,o)=>{try{e.call(n,s,a,t),o()}catch(e){const a=n.hooks;o(),a&&"function"==typeof a.middlewareError?a.middlewareError(t,s,err):warn(`${e}\n\n   --- from middleware [${t}] action.`)}};class Middleware{constructor(t){this.stack=[],this.store=t,this.isProcessing=!1}use(t,e){assert(!this.isProcessing,"can't allow add new middleware in the middleware processing."),this.stack.push({fn:e,action:t})}remove(t,e){const n=this.stack.findIndex(n=>n.fn===e&&n.action===t);n>-1&&this.stack.splice(n,1)}process(t,e,n){this.isProcessing=!0;const s=()=>{this.isProcessing=!1};if(this.stack.length>0){let a=0;const o=e=>{let i=this.stack[a];for(a++;i&&!match(i,t);)i=this.stack[a++];i?handleLayer(t,i.fn,this.store,e,o,s):n(e,s)};o(e)}else n(e,s)}}const applyPatchs=(t,e)=>{const n={};for(let t=0,s=e.length;t<s;t++){const{value:s,path:a}=e[t];n[a]=s}t.setData(n)},updateComponents=(t,e)=>{const n=t.length;if(!(n<=0))for(let s=0;s<n;s++){const{isPage:n,component:a,didUpdate:o,willUpdate:i,createState:r}=t[s];if(a.data[GLOBALWORD]){const t=r();if("function"==typeof i&&!1===i(t))continue;const s=diff(a.data[GLOBALWORD],t,GLOBALWORD);if(s.length>0){if(!1===callHook(e,"willUpdate",[a,t,s,n]))continue;applyPatchs(a,s),"function"==typeof o&&o(t,s),callHook(e,"didUpdate",[a,t,n])}}}};let GLOBALWORD="global";const assertReducer=(t,e,n)=>{const{setter:s,partialState:a}=n;assert("partialState"in n,"You must defined [partialState]."+`\n\n --- from [${e}] action.`),assert(isPlainObject(a),"The [partialState] must be an object."+`\n\n --- from [${e}] action.`);for(const n in a)assert(!t.hasOwnProperty(n),`The [${n}] already exists in global state, `+`Please don't repeat defined. \n\n --- from [${e}] action.`);return"function"!=typeof s&&(n.setter=()=>{throw`Can't changed [${e}] action value. Have you defined a setter?`}),n};class Store{constructor(t){this.state={},this.hooks=t,this.reducers=[],this.depComponents=[],this.isDispatching=!1,this.middleware=new Middleware(this)}add(t,e){assert(!this.reducers.find(e=>e.action===t),`Can't repeat defined [${t}] action.`);const{partialState:n}=assertReducer(this.state,t,e);e.action=t,this.reducers.push(e),this.state=mergeState(this.state,n)}dispatch(t,e,n){const{reducers:s,isDispatching:a}=this;assert(!a,'It is not allowed to call "dispatch" during dispatch execution.'+`\n\n   --- from [${t}] action.`);const o=s.find(e=>e.action===t);assert(o,`The "${t}" does not exist. `+"Maybe you have not defined."),this.middleware.process(t,e,(e,s)=>{this.isDispatching=!0;try{const t=o.setter(this.state,e);assert(isPlainObject(t),"setter function should be return a plain object."),this.state=mergeState(this.state,t)}catch(e){this.isDispatching=!1,s(),warn(`${e}\n\n   --- from [${t}] action.`)}updateComponents(this.depComponents,this.hooks),this.isDispatching=!1,s(),"function"==typeof n&&n()})}use(t,e){return"function"==typeof t&&(e=t,t=COMMONACTION),this.middleware.use(t,e),()=>this.middleware.remove(t,e)}setNamespace(t){assert(t&&"string"==typeof t,"The [namespace] must be a string"),GLOBALWORD=t}_rewirteCfgAndAddDep(t,e){let n=null;const s=this,{data:a,storeConfig:o={}}=t,{didUpdate:i,willUpdate:r,defineReducer:c,usedGlobalState:l}=o;if(delete t.storeConfig,"function"==typeof c&&c.call(s,s),"function"==typeof l){const t=l.call(s,s);assert(isPlainObject(t),"[usedGlobalState] must return a plain object,"+`but now is return a [${typeof t}]`),n=()=>mapObject(t,t=>t(this.state))}if(null!==n){const e=n();isPlainObject(e)&&(a?a[GLOBALWORD]=e:t.data={[GLOBALWORD]:e})}const h=t=>{if(!1!==callHook(this.hooks,"addDep",[t,e])&&null!==n&&isPlainObject(t.data[GLOBALWORD])){this.depComponents.push({isPage:e,component:t,didUpdate:i,willUpdate:r,createState:n});const s=diff(t.data[GLOBALWORD],n());s.length>0&&applyPatchs(t,s)}};if(e)t.onLoad=createWraper(t.onLoad,(function(){h(this),this.store=s})),t.onUnload=createWraper(t.onLoad,null,(function(){this.store=null,remove(s.depComponents,this)}));else{t.lifetimes=t.lifetimes||{};const e=e=>t[e]||t.lifetimes[e],n=(e,n)=>t[e]=t.lifetimes[e]=n;n("attached",createWraper(e("attached"),(function(){h(this),this.store=s}))),n("detached",createWraper(e("detached"),null,(function(){this.store=null,remove(s.depComponents,this)})))}}}const nativePage=Page,nativeComponent=Component,expandConfig=(t,e,n)=>{isEmptyObject(e)||(n?Object.assign(t,e):(t.methods=t.methods||{},Object.assign(t.methods,e)))};function index(t,e){const n=new Store(e),s=mixin(t);return Page=createWraper(nativePage,(function(t){callHook(e,"createBefore",[t,!0]),expandConfig(t,s,!0),n._rewirteCfgAndAddDep(t,!0)})),Component=createWraper(nativeComponent,(function(t){callHook(e,"createBefore",[t,!1]),expandConfig(t,s,!1),n._rewirteCfgAndAddDep(t,!1)})),n}exports.default=index,exports.restore=restore;
