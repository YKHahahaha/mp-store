"use strict";function warn(t){throw new Error(`\n\n[MpStore warn]: ${t}\n\n`)}function assert(t,e){t||warn(e)}function mergeState(t,e){return Object.freeze(Object.assign({},t,e))}function remove(t,e){const n=t.indexOf(e);n>-1&&t.splice(n,1)}function callHook(t,e,n){if(t&&"function"==typeof t[e])return t[e].apply(t,n)}function isEmptyObject(t){for(const e in t)return!1;return!0}function mapObject(t,e){const n={};for(const s in t)t.hasOwnProperty(s)&&(n[s]=e(t[s]));return n}function createWraper(t,e,n){return function(...s){let o;return"function"==typeof e&&e.apply(this,s),"function"==typeof t&&(o=t.apply(this,s)),"function"==typeof n&&n.apply(this,s),o}}function isPlainObject(t){if("object"!=typeof t||null===t)return!1;const e=Object.getPrototypeOf(t);if(null===e)return!0;let n=e;for(;null!==Object.getPrototypeOf(n);)n=Object.getPrototypeOf(n);return e===n}function mixin(t){const e=Object.create(null);if("function"==typeof t){t((t,n)=>{assert("string"==typeof t,"The mixed method name must a string."),assert("function"==typeof n,"The mixed method is not a function."),assert(!(t in e),`The "${t}" is exist,`),e[t]=n})}return e}Object.defineProperty(exports,"__esModule",{value:!0});const ADD=1,REMOVE=2,REPLACE=3;function Patch(t,e,n,s){this.type=t,this.path=e,this.value=n,this.leftValue=s}function diffValues(t,e,n,s){"function"==typeof t||null===t?s.push(new Patch(REPLACE,n,e,t)):Array.isArray(t)?Array.isArray(e)?walkArray(t,e,n,s):s.push(new Patch(REPLACE,n,e,t)):"object"==typeof t?null===e||"object"!=typeof e||Array.isArray(e)?s.push(new Patch(REPLACE,n,e,t)):t instanceof Date||e instanceof Date?s.push(new Patch(REPLACE,n,e,t)):walkObject(t,e,n,s):s.push(new Patch(REPLACE,n,e,t))}function walkArray(t,e,n,s){if(t.length<=e.length){let o=t.length;for(;--o>=0;)if(t[o]!==e[o]){const a=`${n}[${o}]`;diffValues(t[o],e[o],a,s)}if(e.length>t.length)for(o=e.length;--o>=t.length;){const a=`${n}[${o}]`;s.push(new Patch(ADD,a,e[o],t[o]))}}else s.push(new Patch(REPLACE,n,e,t))}function walkObject(t,e,n,s){for(const o in t){const a=`${n}.${o}`;o in e?t[o]!==e[o]&&diffValues(t[o],e[o],a,s):s.push(new Patch(REMOVE,a,null,t[o]))}for(const o in e)if(!(o in t)){const t=`${n}.${o}`;s.push(new Patch(ADD,t,e[o],null))}}function diff(t,e,n){const s=[];return walkObject(t,e,n,s),s}const REG=/(?<=[\[\].])[^\[\].]+/g;function separatePath(t,e){const n=e.match(REG);if(n){let e=-1,s=null,o=t,a=null;for(;e++<n.length-2;)a=o,o=o[s=n[e]];return[o,s,a,n[n.length-1]]}}function restore(t,e){let n=e.length;const s=new Map;for(;--n>=0;){const{type:o,path:a,leftValue:i}=e[n],r=separatePath(t,a);if(r){const[t,e,n,a]=r;switch(o){case REMOVE:case REPLACE:t[a]=i;break;case ADD:Array.isArray(t)&&t===n[e]&&s.set(t,{key:e,prevTarget:n}),delete t[a]}}}return s.forEach(({key:t,prevTarget:e},n)=>{const s=new n.constructor;n.forEach(t=>s.push(t)),e[t]=s}),t}const COMMONACTION="*";function match(t,e){return t.action===COMMONACTION||e===t.action}function handleLayer(t,e,n,s,o,a){try{e.call(n,s,o,t),a()}catch(e){const o=n.hooks;a(),o&&"function"==typeof o.middlewareError?o.middlewareError(t,s,err):warn(`${e}\n\n   --- from middleware [${t}] action.`)}}class Middleware{constructor(t){this.stack=[],this.store=t,this.isProcessing=!1}use(t,e){assert(!this.isProcessing,"can't allow add new middleware in the middleware processing."),this.stack.push({fn:e,action:t})}remove(t,e){const n=this.stack.findIndex(n=>n.fn===e&&n.action===t);n>-1&&this.stack.splice(n,1)}process(t,e,n){this.isProcessing=!0;const s=()=>{this.isProcessing=!1};if(this.stack.length>0){let o=0;const a=e=>{let i=this.stack[o];for(o++;i&&!match(i,t);)i=this.stack[o++];i?handleLayer(t,i.fn,this.store,e,a,s):n(e,s)};a(e)}else n(e,s)}}function applyPatchs(t,e){const n={};for(let t=0,s=e.length;t<s;t++){const{value:s,path:o}=e[t];n[o]=s}t.setData(n)}function updateComponents(t,e){const n=t.length;if(!(n<=0))for(let s=0;s<n;s++){const{isPage:n,component:o,didUpdate:a,willUpdate:i,createState:r}=t[s];if(o.data[GLOBALWORD]){const t=r();if("function"==typeof i&&!1===i(t))continue;const s=diff(o.data[GLOBALWORD],t,GLOBALWORD);if(s.length>0){if(!1===callHook(e,"willUpdate",[o,t,s,n]))continue;applyPatchs(o,s),"function"==typeof a&&a(t,s),callHook(e,"didUpdate",[o,t,n])}}}}let GLOBALWORD="global";function assertReducer(t,e,n){const{setter:s,partialState:o}=n;assert("partialState"in n,"You must defined [partialState]."+`\n\n --- from [${e}] action.`),assert(isPlainObject(o),"The [partialState] must be an object."+`\n\n --- from [${e}] action.`);for(const n in o)assert(!t.hasOwnProperty(n),`The [${n}] already exists in global state, `+`Please don't repeat defined. \n\n --- from [${e}] action.`);return"function"!=typeof s&&(n.setter=()=>{throw`Can't changed [${e}] action value. Have you defined a setter?`}),n}class Store{constructor(t){this.state={},this.hooks=t,this.reducers=[],this.depComponents=[],this.isDispatching=!1,this.version="0.0.3",this.middleware=new Middleware(this)}add(t,e){assert(!this.reducers.find(e=>e.action===t),`Can't repeat defined [${t}] action.`);const{partialState:n}=assertReducer(this.state,t,e);e.action=t,this.reducers.push(e),this.state=mergeState(this.state,n)}dispatch(t,e,n){const{reducers:s,isDispatching:o}=this;assert(!o,'It is not allowed to call "dispatch" during dispatch execution.'+`\n\n   --- from [${t}] action.`);const a=s.find(e=>e.action===t);assert(a,`The "${t}" does not exist. `+"Maybe you have not defined."),this.middleware.process(t,e,(e,s)=>{this.isDispatching=!0;try{const t=a.setter(this.state,e);assert(isPlainObject(t),"setter function should be return a plain object."),this.state=mergeState(this.state,t)}catch(e){this.isDispatching=!1,s(),warn(`${e}\n\n   --- from [${t}] action.`)}updateComponents(this.depComponents,this.hooks),this.isDispatching=!1,s(),"function"==typeof n&&n()})}use(t,e){return"function"==typeof t&&(e=t,t=COMMONACTION),this.middleware.use(t,e),()=>this.middleware.remove(t,e)}setNamespace(t){assert(t&&"string"==typeof t,"The [namespace] must be a string"),GLOBALWORD=t}_rewirteCfgAndAddDep(t,e){let n=null;const s=this,{data:o,storeConfig:a={}}=t,{didUpdate:i,willUpdate:r,defineReducer:c,usedGlobalState:l}=a;if(delete t.storeConfig,"function"==typeof c&&c.call(s,s),"function"==typeof l){const t=l.call(s,s);assert(isPlainObject(t),"[usedGlobalState] must return a plain object,"+`but now is return a [${typeof t}]`),n=()=>mapObject(t,t=>t(this.state))}if(null!==n){const e=n();isPlainObject(e)&&(o?o[GLOBALWORD]=e:t.data={[GLOBALWORD]:e})}const f=t=>{if(!1!==callHook(this.hooks,"addDep",[t,e])&&null!==n&&isPlainObject(t.data[GLOBALWORD])){this.depComponents.push({isPage:e,component:t,didUpdate:i,willUpdate:r,createState:n});const s=diff(t.data[GLOBALWORD],n());s.length>0&&applyPatchs(t,s)}};if(e)t.onLoad=createWraper(t.onLoad,(function(){f(this),this.store=s})),t.onUnload=createWraper(t.onLoad,null,(function(){this.store=null,remove(s.depComponents,this)}));else{t.lifetimes=t.lifetimes||{};const e=e=>t[e]||t.lifetimes[e],n=(e,n)=>t[e]=t.lifetimes[e]=n;n("attached",createWraper(e("attached"),(function(){f(this),this.store=s}))),n("detached",createWraper(e("detached"),null,(function(){this.store=null,remove(s.depComponents,this)})))}}}const version="0.0.3",nativePage=Page,nativeComponent=Component;function expandConfig(t,e,n){isEmptyObject(e)||(n?Object.assign(t,e):(t.methods=t.methods||{},Object.assign(t.methods,e)))}function createStore(t,e){const n=new Store(e),s=mixin(t);return Page=createWraper(nativePage,(function(t){callHook(e,"createBefore",[t,!0]),expandConfig(t,s,!0),n._rewirteCfgAndAddDep(t,!0)})),Component=createWraper(nativeComponent,(function(t){callHook(e,"createBefore",[t,!1]),expandConfig(t,s,!1),n._rewirteCfgAndAddDep(t,!1)})),n}exports.createStore=createStore,exports.restore=restore,exports.version="0.0.3";
